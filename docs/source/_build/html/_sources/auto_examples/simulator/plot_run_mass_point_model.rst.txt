
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/simulator/plot_run_mass_point_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_simulator_plot_run_mass_point_model.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_simulator_plot_run_mass_point_model.py:


RunSimulator: Mass Point Model
==============================

.. GENERATED FROM PYTHON SOURCE LINES 8-12

This example shows how to run multiple MassPointModel simulations in serial
and parallelly using :class:`.RunSimulator`.



.. GENERATED FROM PYTHON SOURCE LINES 16-18

First, we import the class :class:`.MassPointModel` and define a `simulator`
based on :py:meth:`.MassPointModel.run` method.

.. GENERATED FROM PYTHON SOURCE LINES 19-26

.. code-block:: default


    from psimpy.simulator import MassPointModel

    mpm = MassPointModel()
    mpm_simulator = mpm.run









.. GENERATED FROM PYTHON SOURCE LINES 27-39

This simulator takes required input data, solves the mass point model, and
returns time history of the mass point's location and velocity
(see :py:meth:`.MassPointModel.run`).

Required inputs for `mpm_simulator` include:
    1. topographic data: digital elevation model (in `ESRI ascii` format)
    2. friction coefficients: coulomb friction and turbulent friction coefficients
    3. initial state: initial location and initial velocity of the masspoint
    4. computational parameters: such as time step, end time, etc.

The synthetic topography ``synthetic_topo.asc`` is used here for illustration.
It is located at the `/tests/data/` folder.

.. GENERATED FROM PYTHON SOURCE LINES 40-46

.. code-block:: default


    import os

    dir_data = os.path.abspath('../../../tests/data/')
    elevation = os.path.join(dir_data, 'synthetic_topo.asc')








.. GENERATED FROM PYTHON SOURCE LINES 47-49

.. note:: You may need to modify ``dir_data`` according to where you save
   ``synthetic_topo.asc`` on your local machine.

.. GENERATED FROM PYTHON SOURCE LINES 51-57

For this example, we are going to run multiple simulations at different values
of coulomb friction coefficient (``coulomb_friction``) and turbulent friction
coefficient (``turbulent_friction``) while keep other inputs fixed. Namely,
``coulomb_friction`` and ``turbulent_friction`` are variable input parameters.
All other inputs are fixed input parameters.


.. GENERATED FROM PYTHON SOURCE LINES 58-74

.. code-block:: default


    import numpy as np
    import itertools

    # Variable iput parameters are defined as a list of strings. Their values will be
    # passed as a numpy array (var_samples) when run simulations.
    var_inp_parameter = ['coulomb_friction', 'turbulent_friction']
    coulomb_friction = np.arange(0.1, 0.31, 0.1)
    turbulent_friction = np.arange(500, 2001, 400)
    var_samples = np.array(
        [x for x in itertools.product(coulomb_friction, turbulent_friction)])
    print("Number of variable input samples are: ", len(var_samples))

    # Fixed input parameters are defined as a dictionary. Their values are given.
    fix_inp = {'elevation': elevation, 'x0': 200, 'y0': 2000, 'tend': 50}





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of variable input samples are:  12




.. GENERATED FROM PYTHON SOURCE LINES 75-78

.. note:: Parameters of `mpm_simulator` which are not included in
   ``var_inp_parameter`` and ``fix_inp``, such as ``ux0``, ``uy0`` and
   ``curvature``, will automatically take their default values.

.. GENERATED FROM PYTHON SOURCE LINES 80-83

We may want to save outputs returned by `mpm_simulator` at each simulation for
later inspection or processing. In that case, we need to define ``dir_out`` and
set ``save_out`` as `True`.

.. GENERATED FROM PYTHON SOURCE LINES 84-95

.. code-block:: default


    import os

    # Here we create a folder called `temp_run_MassPointModel_example` to save outputs
    # returned at each simulation.
    cwd = os.getcwd()
    if not os.path.exists('temp_run_MassPointModel_example'):
        os.mkdir('temp_run_MassPointModel_example')
    dir_out = os.path.join(cwd, 'temp_run_MassPointModel_example')









.. GENERATED FROM PYTHON SOURCE LINES 96-97

Now we can define an object of :class:`.RunSimulator` by

.. GENERATED FROM PYTHON SOURCE LINES 98-104

.. code-block:: default


    from psimpy.simulator import RunSimulator

    run_mpm_simulator = RunSimulator(mpm_simulator, var_inp_parameter, fix_inp,
        dir_out=dir_out, save_out=True)








.. GENERATED FROM PYTHON SOURCE LINES 105-108

.. note:: Since outputs of each simulation are saved in the same folder ``dir_out``,
   we need to give each file a unique name in order to avoid conflict. This is
   realized by defining ``prefixes``.

.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: default


    serial_prefixes = ["serial"+str(i) for i in range(len(var_samples))]
    parallel_prefixes = ["parallel"+str(i) for i in range(len(var_samples))]









.. GENERATED FROM PYTHON SOURCE LINES 114-117

Using :py:meth:`.RunSimulator.serial_run` method or
:py:meth:`.RunSimulator.parallel_run` method, we can run the simulations
in serial or parallelly.

.. GENERATED FROM PYTHON SOURCE LINES 118-136

.. code-block:: default


    import time

    start = time.time()
    run_mpm_simulator.serial_run(var_samples=var_samples, prefixes=serial_prefixes)
    serial_time = time.time() - start
    serial_output = run_mpm_simulator.outputs

    start = time.time()
    # max_workers controls maximum number of tasks running in parallel
    run_mpm_simulator.parallel_run(var_samples, prefixes=parallel_prefixes, max_workers=4)
    parallel_time = time.time() - start
    parallel_output = run_mpm_simulator.outputs
    
    print("Serial run time: ", serial_time)
    print("Parallel run time: ", parallel_time)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Serial run time:  0.691016674041748
    Parallel run time:  0.2793431282043457




.. GENERATED FROM PYTHON SOURCE LINES 137-139

Once a simulation is done, its output is saved to ``dir_out``. All output files
generated by above simulations are as follows: 

.. GENERATED FROM PYTHON SOURCE LINES 140-144

.. code-block:: default


    os.listdir(dir_out)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['parallel1_output.npy', 'parallel0_output.npy', 'parallel11_output.npy', 'serial2_output.npy', 'parallel3_output.npy', 'parallel7_output.npy', 'parallel10_output.npy', 'parallel9_output.npy', 'parallel6_output.npy', 'parallel4_output.npy', 'parallel5_output.npy', 'serial3_output.npy', 'serial9_output.npy', 'serial0_output.npy', 'serial5_output.npy', 'parallel2_output.npy', 'serial8_output.npy', 'serial10_output.npy', 'serial1_output.npy', 'serial6_output.npy', 'parallel8_output.npy', 'serial11_output.npy', 'serial4_output.npy', 'serial7_output.npy']



.. GENERATED FROM PYTHON SOURCE LINES 145-147

Once all simulations are done, their outputs can also be accessed by
:py:attr:`.RunSimulator.outputs` attribute, which is a list.

.. GENERATED FROM PYTHON SOURCE LINES 148-157

.. code-block:: default


    # Here we print the maximum velocity of each simulation in the parallel run.
    max_v = [np.max(output[:,5]) for output in parallel_output]
    print(
        f"Maximum velocity of {parallel_prefixes[0]} to {parallel_prefixes[-1]} are: ",
        '\n',
        max_v)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Maximum velocity of parallel0 to parallel11 are:  
     [16.55505557211892, 22.014114896121015, 26.245546886730782, 29.78487303612985, 15.34198274528081, 20.371864007499866, 24.249957243412815, 27.485487855011687, 14.031665649204944, 18.589324449452967, 22.092803891476187, 24.99727320816709]




.. GENERATED FROM PYTHON SOURCE LINES 158-164

.. warning:: If one simulation failed due to whatever reason, the error massage
   will be printed to the screen but other simulations will continue. In that 
   case, the output file of failed simulation will not be writted to ``dir_out``.
   Also, the element of :py:attr:`.RunSimulator.outputs` corresponding to that
   simulation will be a string representing the error message, instead of a
   numpy array.

.. GENERATED FROM PYTHON SOURCE LINES 167-168

Here we delete the folder `temp_run_MassPointModel_example` and all files therein.

.. GENERATED FROM PYTHON SOURCE LINES 169-185

.. code-block:: default


    import shutil

    shutil.rmtree(dir_out)


 

















.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.976 seconds)


.. _sphx_glr_download_auto_examples_simulator_plot_run_mass_point_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_run_mass_point_model.py <plot_run_mass_point_model.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_run_mass_point_model.ipynb <plot_run_mass_point_model.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
